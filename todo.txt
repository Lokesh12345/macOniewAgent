ğŸ”§ PHASE 1: Puppeteer & Browser Context Optimization (MUST DO FIRST)
ğŸ¯ Objective: Ensure that browser automation is stable, fast, and persistent across steps.

âœ… Checklist:
Create a centralized BrowserManager.ts

ğŸ“ File: utils/browserManager.ts

ğŸ”§ Use a singleton to maintain a persistent Puppeteer connection

ğŸ§  Avoid calling puppeteer.connect() or launch() on every step

Preserve tabs across agents

ğŸ“ Inside Navigator â†’ store tabId or pageId

ğŸ”§ Reuse same tab for all actions unless explicitly told to open a new one

Avoid full DOM rebuild if already cached

ğŸ“ Content script (content.js)

ğŸ”§ Cache DOM tree on first read, only refresh if mutationObserver detects major layout change

Preserve DOM element handles

ğŸ”§ Instead of using string-based selectors every time, store element handles where possible (e.g., .click() directly)

âš ï¸ Needs injection-side support, may require WeakMap to avoid memory leaks

Maintain shared memory across agents

ğŸ“ Shared object: sessionContext.ts

ğŸ§  Store planner/navigator/validator shared context here â€” current URL, last action, etc.

Reconnect logic for tab reloads

ğŸ”§ Detect if content script reloaded (e.g., after Gmail compose box opens)

ğŸ” Re-inject agent code but reuse old memory/state

ğŸ‘¨â€ğŸ’» Assigned to: Infra Engineer / Navigator Dev

ğŸ§± PHASE 2: Core Agent Loop Setup
ğŸ¯ Objective: Establish a stable loop that converts user goals into a plan, executes it, and validates success.

âœ… Checklist:
Inject actual user goal into planner.ts

ğŸ“ planner.ts

ğŸ”§ Accept dynamic input instead of hardcoded test cases

Call qwen3:14B via Ollama inside Planner

ğŸ“ llm/qwen-planner.ts

ğŸ§  Use fetch('http://localhost:11434/api/generate') with body including temp and top_p

Parse planner output JSON

ğŸ“ planner.ts

ğŸ”§ Parse next_steps, reasoning, done flag from LLM response

Pass steps to builder.ts

ğŸ“ builder.ts

ğŸ”§ Convert planner output into ActionStep[] â†’ e.g. type: click, selector: input[name=q], etc.

Navigator executes actions

ğŸ“ navigator.ts

ğŸ§  Use DOM tree or page object from browserManager to run actions (click, type, scroll)

Validator checks results

ğŸ“ validator.ts

ğŸ”§ Basic validation for now â€” verify element exists or URL matches expected

Log final result

ğŸ“ logger.ts

ğŸ§  Store JSON object: { goal, steps, success, reasoning, timestamp }

ğŸ‘¨â€ğŸ’» Assigned to: Planner Engineer, Navigator Dev, Validator Dev

Let me know if you want the same level of detailed breakdown for Phase 3 onward â€” batching, vision, memory, smart retry, etc.




ChatGPT said:
Hereâ€™s the continued To-Do list with full implementation notes and developer roles â€” for Phases 3, 4, 5, and Final Hardening:

ğŸ§  PHASE 3: Multi-Step Action Batching
ğŸ¯ Objective: Mimic human-like behavior â€” perform grouped actions (like filling a form) without validating after each one.

âœ… Checklist:
Planner supports batch: true

ğŸ“ planner.ts â†’ modify prompt template

ğŸ”§ LLM should output { steps: [...], batch: true }

ğŸ§  Update agent call to handle and expect batch flag

Create ActionBatchExecutor.ts

ğŸ“ New file: action/ActionBatchExecutor.ts

ğŸ”§ Accepts array of actions and runs them in sequence

ğŸ§  Use same Puppeteer tab and DOM snapshot

Skip Validator until entire batch finishes

ğŸ“ navigator.ts

ğŸ”§ Add optional skipValidation: true flag

âœ… Validate only once per batch

Log batch context

ğŸ“ logger.ts

ğŸ§  Mark logs with batch_id, steps count, and result

ğŸ‘¨â€ğŸ’» Assigned to: Planner Dev, Batch Handler Dev

ğŸ‘ï¸ PHASE 4: Vision Fallback System
ğŸ¯ Objective: Use screenshot + OCR when DOM fails (canvas, Figma, Canva, etc.)

âœ… Checklist:
Capture screenshot of current Chrome tab

ğŸ“ Chrome Extension background

ğŸ”§ Use chrome.tabs.captureVisibleTab() with format: 'png'

Run OCR+VL model via Ollama

ğŸ“ visionAgent.ts

ğŸ§  Use qwen2.5vl:7b with prompt like:
â€œHere is a screenshot and goal: {goal}. What elements are visible?â€

Parse detected UI elements

ğŸ“ visionAgent.ts

ğŸ”§ Extract bounding boxes, text labels, and type (button/input)

Match clicks to OCR regions

ğŸ“ navigator.ts fallback branch

ğŸ§  Use coordinates from OCR and chrome.scripting.executeScript() to click visually

Vision Planner if DOM completely fails

ğŸ“ New planner-vision.ts

ğŸ”§ Same planning logic, but prompt should describe visible UI from vision result

ğŸ‘¨â€ğŸ’» Assigned to: Vision Agent Dev, Screenshot Dev

ğŸ§  PHASE 5: Agent Memory & Smart Retry
ğŸ¯ Objective: Enable intelligent retry, avoid repeating successful steps, and persist memory across pages.

âœ… Checklist:
Build AgentMemoryManager.ts

ğŸ“ New file: memory/AgentMemoryManager.ts

ğŸ”§ Store:

Last 10 actions

Current tab ID, current goal

DOM elements interacted

Use memory in Planner

ğŸ“ planner.ts

ğŸ§  Inject memory context before goal (e.g., â€œYou already clicked Xâ€)

Skip redundant steps

ğŸ“ navigator.ts

ğŸ”§ If element already clicked and not changed, skip

SmartRetryManager.ts

ğŸ“ New file

ğŸ”§ Retry with:

Alternative selectors

Scrolling

Tab refresh

Vision fallback (if DOM fails twice)

Log retries with reasons

ğŸ“ logger.ts

ğŸ§  Add retry_count, fallback_used, failure_reason

ğŸ‘¨â€ğŸ’» Assigned to: Memory Dev, Retry Handler Dev

ğŸ“¦ FINAL PHASE: UX, Logs, UI & Metrics
ğŸ¯ Objective: Production polish â€” visibility into agent behavior, success %, debugging, replay.

âœ… Checklist:
Agent Side Panel UI

ğŸ“ popup.html + sidepanel.html

ğŸ”§ Show live: current goal, step in progress, batch ID, fallback used

Visual Step Trace

ğŸ“ DOM overlay script

ğŸ§  Highlight each clicked element during execution

Logs & Replay

ğŸ“ logger.ts

ğŸ”§ Store logs in IndexedDB or chrome.storage.local

âœ… Add export as .json option

Metrics Dashboard

ğŸ“ dashboard.ts

ğŸ§  Track:

% goals completed

Avg steps per task

Retry rate

Fallback usage

Model auto-switching logic

ğŸ“ llm/modelRouter.ts

ğŸ”§ Route to cheaper/faster model based on token count or temp config

ğŸ‘¨â€ğŸ’» Assigned to: UI Dev, Infra Dev, Analyst Dev